namespace SysCredit.Toolkits.Generators.Models;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using System.Collections.Immutable;
using System.Linq;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/// <inheritdoc/>
partial record HierarchyInfo
{
    /// <summary>
    ///     Creates a <see cref="CompilationUnitSyntax"/> instance wrapping the given members.
    /// </summary>
    /// <param name="MemberDeclarations">
    ///     The input <see cref="MemberDeclarationSyntax"/> instances to use.
    /// </param>
    /// <param name="BaseList">
    ///     The optional <see cref="BaseListSyntax"/> instance to add to generated types.
    /// </param>
    /// <returns>
    ///     A <see cref="CompilationUnitSyntax"/> object wrapping <paramref name="MemberDeclarations"/>.
    /// </returns>
    public CompilationUnitSyntax GetCompilationUnit(ImmutableArray<MemberDeclarationSyntax> MemberDeclarations, BaseListSyntax? BaseList = null)
    {
        // Create the partial type declaration with the given member declarations.
        // This code produces a class declaration as follows:
        //
        // /// <inheritdoc/>
        // partial <TYPE_KIND> TYPE_NAME>
        // {
        //     <MEMBERS>
        // }
        TypeDeclarationSyntax TypeDeclarationSyntax = Hierarchy[0].GetSyntax()
            .AddModifiers(Token(TriviaList(Comment("/// <inheritdoc/>")), SyntaxKind.PartialKeyword, TriviaList()))
            .AddMembers(MemberDeclarations.ToArray());

        // Add the base list, if present
        if (BaseList is not null)
        {
            TypeDeclarationSyntax = TypeDeclarationSyntax.WithBaseList(BaseList);
        }

        // Add all parent types in ascending order, if any
        foreach (TypeInfo ParentType in Hierarchy.AsSpan().Slice(1))
        {
            TypeDeclarationSyntax = ParentType.GetSyntax()
                .AddModifiers(Token(TriviaList(Comment("/// <inheritdoc/>")), SyntaxKind.PartialKeyword, TriviaList()))
                .AddMembers(TypeDeclarationSyntax);
        }

        // Prepare the leading trivia for the generated compilation unit.
        // This will produce code as follows:
        //
        // <auto-generated/>
        // #pragma warning disable
        // #nullable enable
        SyntaxTriviaList SyntaxTriviaList = TriviaList(
            Comment("// <auto-generated/>"),
            Trivia(PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true)),
            Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)));

        if (Namespace is "")
        {
            // Special case for top level types with no namespace: we need to re-add the
            // inheritdoc XML comment, as otherwise the call below would remove it.
            SyntaxTriviaList = SyntaxTriviaList.Add(Comment("/// <inheritdoc/>"));

            // If there is no namespace, attach the pragma directly to the declared type,
            // and skip the namespace declaration. This will produce code as follows:
            //
            // <SYNTAX_TRIVIA>
            // <TYPE_HIERARCHY>
            return CompilationUnit()
                    .AddMembers(TypeDeclarationSyntax.WithLeadingTrivia(SyntaxTriviaList))
                    .NormalizeWhitespace();
        }

        // Create the compilation unit with disabled warnings, target namespace and generated type.
        // This will produce code as follows:
        //
        // <SYNTAX_TRIVIA>
        // namespace <NAMESPACE>
        // {
        //     <TYPE_HIERARCHY>
        // }
        return CompilationUnit().AddMembers(NamespaceDeclaration(IdentifierName(Namespace))
                .WithLeadingTrivia(SyntaxTriviaList)
                .AddMembers(TypeDeclarationSyntax))
                .NormalizeWhitespace();
    }
}
